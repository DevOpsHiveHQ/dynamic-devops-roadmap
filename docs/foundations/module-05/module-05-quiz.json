{
  "quizTitle": "Module 5: Transform - Finishing the Structure Quiz",
  "quizSynopsis": "Assess your understanding of refining goals, external systems integration, integration testing, IaC, Terraform, Kubernetes config management, log aggregation, and CD best practices.",
  "progressBarColor": "#64a725",
  "nrOfQuestions": "20",
  "questions": [
    {
      "question": "At this stage, why should you revisit and refine your project's goals and requirements?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To discard all initial requirements",
        "To focus solely on technical details and ignore business needs",
        "To delay further development indefinitely",
        "To ensure alignment with current business objectives and user feedback"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Continuous refinement ensures your solutions match evolving business goals and user insights.",
      "messageForIncorrectAnswer": "Incorrect. Refining goals ensures alignment with business and user needs.",
      "point": "10"
    },
    {
      "question": "Why consider user feedback when adjusting project goals?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because user feedback helps shape improvements and ensure relevance",
        "To ignore their suggestions and stick to the original plan",
        "To make the project harder to use",
        "To remove all features users enjoy"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! User feedback helps refine the solution to better meet real-world needs.",
      "messageForIncorrectAnswer": "Incorrect. Listening to users guides meaningful improvements.",
      "point": "10"
    },
    {
      "question": "What is a benefit of involving cross-functional teams (like QA) in refinement?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Increased project confusion",
        "A smoother end-to-end delivery by ensuring quality and collaboration",
        "Reduced communication between teams",
        "Slower response to user feedback"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Engaging various teams ensures quality, reliability, and overall better delivery.",
      "messageForIncorrectAnswer": "Incorrect. Collaboration improves the project's quality and flow.",
      "point": "10"
    },
    {
      "question": "How should planning be treated during the ongoing project life cycle?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "As fixed and unchanging",
        "As something to ignore once development starts",
        "As a moving target that should be iterated upon as needs evolve",
        "As a barrier to user feedback"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Planning is iterative and should evolve with changing requirements and insights.",
      "messageForIncorrectAnswer": "Incorrect. Planning should adapt as circumstances change.",
      "point": "10"
    },
    {
      "question": "Why establish continuous feedback loops now?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To avoid any form of communication",
        "To ignore changing requirements",
        "To prevent responding to user needs",
        "To regularly adjust direction based on ongoing input"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Continuous feedback loops help fine-tune development in response to real-time insights.",
      "messageForIncorrectAnswer": "Incorrect. Ongoing feedback refines your approach continuously.",
      "point": "10"
    },
    {
      "question": "Why is it often better to use an official SDK or library when interacting with external systems?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because it provides tested, reliable interfaces and reduces maintenance overhead",
        "Because writing all code from scratch is always easier",
        "Because official SDKs never handle errors",
        "Because official SDKs reduce code clarity"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Official SDKs simplify integrations by providing stable, maintained interfaces.",
      "messageForIncorrectAnswer": "Incorrect. SDKs or libraries save time and ensure reliability.",
      "point": "10"
    },
    {
      "question": "How should you handle rate limits when working with external APIs?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Ignore them entirely",
        "Implement strategies like exponential backoff to avoid hitting limits",
        "Perform continuous, unlimited requests",
        "Stop all requests after first rate limit error"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Use techniques like exponential backoff to stay within rate limits and maintain stability.",
      "messageForIncorrectAnswer": "Incorrect. Respecting rate limits ensures smooth, reliable API consumption.",
      "point": "10"
    },
    {
      "question": "Why consider asynchronous communication methods (e.g., message queues) with external systems?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To force synchronous slowdowns",
        "To skip error handling",
        "To handle latency and load by decoupling requests and responses",
        "To avoid caching"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Async methods handle spikes, delays, and failures gracefully, improving scalability.",
      "messageForIncorrectAnswer": "Incorrect. Queues and async patterns help manage load and reliability.",
      "point": "10"
    },
    {
      "question": "What is a recommended approach when retrieving large data sets from an external system?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Make a single huge request that might fail",
        "Ignore pagination and hope for the best",
        "Use pagination or chunked responses to handle data efficiently",
        "Refuse to process large data sets"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Paginating responses prevents timeouts and improves performance.",
      "messageForIncorrectAnswer": "Incorrect. Large data sets should be handled in manageable chunks.",
      "point": "10"
    },
    {
      "question": "Why consider caching results from external systems?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Caching increases unnecessary calls",
        "Caching always returns stale data",
        "Caching reduces repeated requests, saving time and resources",
        "Caching never helps with performance"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Caching avoids unnecessary repeated calls, improving efficiency and response time.",
      "messageForIncorrectAnswer": "Incorrect. Caching is a common strategy to improve performance and reduce load.",
      "point": "10"
    },
    {
      "question": "What do integration tests focus on?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Testing individual units in isolation",
        "Verifying that combined components work together correctly",
        "Ignoring how modules interact",
        "Focusing solely on UI design"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Integration tests ensure different parts of the system collaborate as intended.",
      "messageForIncorrectAnswer": "Incorrect. Integration tests validate interactions between modules.",
      "point": "10"
    },
    {
      "question": "When writing integration tests, what should you keep in mind?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Complex, hard-to-maintain test code",
        "Avoid real systems at all costs",
        "Keep tests simple, use realistic test data, and prefer real systems or proper stubs",
        "Only test happy paths"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Simple, realistic tests with actual systems increase reliability and relevance.",
      "messageForIncorrectAnswer": "Incorrect. Integration tests should be as realistic and maintainable as possible.",
      "point": "10"
    },
    {
      "question": "Why run integration tests in an environment close to production?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To ensure tests run slower",
        "To reduce the accuracy of test results",
        "To detect issues that might appear in production-like conditions",
        "To ignore environment differences"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! A production-like environment increases the likelihood of catching real-world issues early.",
      "messageForIncorrectAnswer": "Incorrect. Similar conditions reveal environment-specific problems.",
      "point": "10"
    },
    {
      "question": "What is a good practice regarding integration test data?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Use completely random, meaningless data",
        "Use minimal, realistic test data to simulate real use cases",
        "Never clean up test data",
        "Make tests depend on each other's data"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Representative, minimal test data reflects real scenarios without overcomplicating tests.",
      "messageForIncorrectAnswer": "Incorrect. Realistic test data improves relevance and accuracy.",
      "point": "10"
    },
    {
      "question": "How should integration tests handle external services?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Ignore them completely",
        "Use production APIs directly without caution",
        "Use sandbox/test environments or mocked/stubbed endpoints if real ones aren't available",
        "Rely solely on manual verification"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Test with sandbox APIs or mocks to safely simulate external service behavior.",
      "messageForIncorrectAnswer": "Incorrect. Use proper test environments or mocks to avoid impacting production.",
      "point": "10"
    },
    {
      "question": "What does Infrastructure as Code (IaC) provide?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "A manual approach to provisioning infrastructure",
        "A way to manage infrastructure using code-like files for consistency and repeatability",
        "A process that discourages source control",
        "A replacement for all programming languages"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! IaC uses code-like definitions for predictable, repeatable infrastructure provisioning.",
      "messageForIncorrectAnswer": "Incorrect. IaC treats infrastructure setup as code, enhancing reliability.",
      "point": "10"
    },
    {
      "question": "Why is a declarative approach preferred in IaC?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "It makes infrastructure setup more complicated",
        "It forces manual intervention",
        "It lets you state the desired end state and let the tool figure out how to achieve it",
        "It removes predictability"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Declarative IaC focuses on the 'what', not the 'how', simplifying management.",
      "messageForIncorrectAnswer": "Incorrect. Declarative defines the end goal, the tool handles the details.",
      "point": "10"
    },
    {
      "question": "What is a key benefit of idempotency in IaC?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "It makes configurations unpredictable",
        "It prevents stable provisioning",
        "It ensures running the same code multiple times produces the same result",
        "It forces manual fixes each run"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Idempotency ensures reliability and consistency on repeated executions.",
      "messageForIncorrectAnswer": "Incorrect. Idempotent IaC yields predictable outcomes every run.",
      "point": "10"
    },
    {
      "question": "Why avoid imperative scripts for IaC?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They are easier to maintain than declarative",
        "They scale well with complexity",
        "They can be harder to maintain and don't leverage IaC tooling benefits",
        "They automatically ensure idempotency"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Imperative scripts are less maintainable and don't exploit declarative IaC advantages.",
      "messageForIncorrectAnswer": "Incorrect. Declarative and IaC tools reduce complexity more effectively.",
      "point": "10"
    },
    {
      "question": "What is Terraform primarily known for?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Being a manual configuration tool",
        "Only working with one cloud provider",
        "Providing multi-cloud IaC with a declarative DSL and state management",
        "Eliminating the need for code repositories"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Terraform supports multiple providers, is declarative, and tracks state for reliable IaC.",
      "messageForIncorrectAnswer": "Incorrect. Terraform is a multi-cloud, declarative IaC tool with stateful approach.",
      "point": "10"
    },
    {
      "question": "What should you never do with Terraform state in a team environment?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Store it locally",
        "Use remote storage like S3",
        "Check state into version control",
        "Encrypt it for security"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Storing state locally hinders collaboration and can cause consistency issues.",
      "messageForIncorrectAnswer": "Incorrect. Remote storage avoids conflicts and improves team workflows.",
      "point": "10"
    },
    {
      "question": "What does Terraform encourage to reduce code duplication?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Rewriting the same resources repeatedly",
        "Using no modules",
        "Utilizing modules and Registry resources for DRY configurations",
        "Avoiding official modules"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Modules help reuse patterns and keep IaC DRY and maintainable.",
      "messageForIncorrectAnswer": "Incorrect. Modules prevent repeating the same code multiple times.",
      "point": "10"
    },
    {
      "question": "After creating a Kubernetes cluster with Terraform, how should you manage Kubernetes apps?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Continue using Terraform for app deployment",
        "Switch to Kubernetes-native tools (like Helm or Kustomize) for managing apps",
        "Ignore Kubernetes best practices",
        "Use only imperative kubectl commands"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Use Kubernetes-native tools for app configuration after setting up the cluster with Terraform.",
      "messageForIncorrectAnswer": "Incorrect. Kubernetes resources should be managed with Kubernetes-oriented tools.",
      "point": "10"
    },
    {
      "question": "Which tools are commonly used to manage Kubernetes configuration?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Only manual editing of YAML files",
        "Chef and Puppet",
        "Kustomize and Helm",
        "Terraform only"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Kustomize and Helm are popular for declarative Kubernetes config management.",
      "messageForIncorrectAnswer": "Incorrect. Kustomize and Helm streamline Kubernetes configuration.",
      "point": "10"
    },
    {
      "question": "What is Helm known for in the Kubernetes ecosystem?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Being the official Kubernetes CLI",
        "Having no templating features",
        "Providing charts (templates) for packaging and deploying apps",
        "Replacing Kubernetes API"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Helm uses charts (templates) to simplify deploying and managing complex applications.",
      "messageForIncorrectAnswer": "Incorrect. Helm helps manage Kubernetes apps using templated manifests.",
      "point": "10"
    },
    {
      "question": "How should Kubernetes configuration be treated?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "As a one-time manual setup",
        "As something not worth versioning",
        "As Infrastructure as Code, following declarative and automated practices",
        "As ad hoc commands typed on the fly"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Treating Kubernetes configs as IaC ensures consistency, scalability, and reliability.",
      "messageForIncorrectAnswer": "Incorrect. Apply IaC principles to Kubernetes config for long-term maintainability.",
      "point": "10"
    },
    {
      "question": "Why aggregate logs in a centralized system?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To complicate debugging",
        "To ensure each service logs are isolated and inaccessible",
        "To simplify access, analysis, and correlation of events across systems",
        "To increase storage costs unnecessarily"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Centralized logs make troubleshooting easier and enable cross-system insights.",
      "messageForIncorrectAnswer": "Incorrect. Aggregation simplifies log analysis and debugging.",
      "point": "10"
    },
    {
      "question": "Which log type is easiest to query and analyze?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Unstructured logs",
        "Structured logs",
        "Completely random text",
        "Logs with no timestamps"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Structured logs contain organized data (e.g., JSON), making searches and analysis straightforward.",
      "messageForIncorrectAnswer": "Incorrect. Structured logs are more machine-readable and filterable.",
      "point": "10"
    },
    {
      "question": "What should you ensure before storing logs?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They contain sensitive personal data in plain text",
        "They use random formats each time",
        "They are enriched with metadata, sanitized, and comply with privacy regulations",
        "They are never rotated or managed"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Properly enriched, sanitized, and compliant logs enhance security and usefulness.",
      "messageForIncorrectAnswer": "Incorrect. Ensure logs meet privacy, compliance, and clarity standards.",
      "point": "10"
    },
    {
      "question": "Why avoid storing all possible logs without discrimination?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "More logs always mean better insight",
        "Unlimited logs reduce performance",
        "Excessive logging can create a 'log swamp', increasing costs and making analysis harder",
        "Users expect infinite logging"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Filtering logs to what's relevant saves storage, costs, and eases analysis.",
      "messageForIncorrectAnswer": "Incorrect. Managing log volume is crucial for efficiency and clarity.",
      "point": "10"
    },
    {
      "question": "What is the main goal of Continuous Delivery (CD)?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To never deploy changes",
        "To rely solely on manual deployments",
        "To ensure code changes are always ready for release, safely and quickly",
        "To separate code from testing"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! CD prepares changes so they can be released at any time, improving delivery speed and safety.",
      "messageForIncorrectAnswer": "Incorrect. CD ensures rapid, reliable readiness for release.",
      "point": "10"
    },
    {
      "question": "What is a CD best practice regarding artifact creation?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Build artifacts multiple times in each environment",
        "Never promote the same artifact",
        "Build once, then promote the same artifact through different stages",
        "Build artifacts differently in each stage"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Building once ensures consistency, testing the same artifact across environments.",
      "messageForIncorrectAnswer": "Incorrect. Reusing the same artifact guarantees consistent testing and deployment.",
      "point": "10"
    },
    {
      "question": "How should test environments be treated in a CD pipeline?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They should all be dependent on each other",
        "They should influence one another's results",
        "They should remain independent to ensure accurate results",
        "They should never be refreshed"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Independent test environments prevent cross-contamination of results.",
      "messageForIncorrectAnswer": "Incorrect. Isolation ensures each environmentâ€™s tests are reliable.",
      "point": "10"
    },
    {
      "question": "Why gather human feedback in addition to system feedback in CD?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because human feedback slows down improvement",
        "Because system feedback is always perfect",
        "Because developers and users provide insights beyond what automated tests reveal",
        "Because human input is never needed"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Human perspectives add valuable context and identify issues automation may miss.",
      "messageForIncorrectAnswer": "Incorrect. Combine system metrics with human insight for holistic improvement.",
      "point": "10"
    },
    {
      "question": "What is the ultimate aim of continuous delivery best practices?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To slow releases down",
        "To avoid any learning or improvement",
        "To continuously improve speed, quality, and reliability of software delivery",
        "To eliminate all automation"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! CD best practices drive ongoing improvement in delivering high-quality software faster.",
      "messageForIncorrectAnswer": "Incorrect. CD focuses on enhancing speed, quality, and dependability.",
      "point": "10"
    }
  ]
}